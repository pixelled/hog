use std::cmp::{min, max};
use std::path::Path;
use std::fs::File;
use std::io::{BufReader, BufRead, BufWriter, Write};
use rayon::iter::{IntoParallelIterator, ParallelIterator};

pub trait Strategy {
    fn play(&self, self_score: u32, oppo_score: u32) -> u32;
    fn full_play(&self, self_score: u32, oppo_score: u32, self_prev: u32, oppo_prev: u32) -> u32 {
        self.play(self_score, oppo_score)
    }
}

#[derive(Clone)]
pub struct PureStrategy(Vec<u32>);

impl PureStrategy {
    pub fn new(data: Vec<u32>) -> Self {
        PureStrategy(data)
    }

    pub fn all(rolls: u32) -> Self {
        PureStrategy(vec![rolls; 10000])
    }

    pub fn import<P: AsRef<Path>>(path: P) -> std::io::Result<Self> {
        let mut data = Vec::with_capacity(10000);
        let file = File::open(path)?;
        let reader = BufReader::new(file);
        for line in reader.lines() {
            data.append(&mut line.unwrap().split(' ').map(|s| s.parse::<u32>().unwrap()).collect())
        }
        Ok(PureStrategy(data))
    }

    pub fn export<P: AsRef<Path>>(&self, path: P) -> std::io::Result<()> {
        let file = File::create(path)?;
        let mut writer = BufWriter::new(file);
        for (i, &rolls) in self.0.iter().enumerate() {
            write!(writer, "{}{}", rolls, if i % 100 == 99 { '\n' } else { ' ' });
        }
        Ok(())
    }

    pub fn improve<S: Strategy + Sync>(&mut self, base: &S) {
        for total in (99..199u32).rev() {
            ((total - 99)..100).into_par_iter().map(|score| (score, total - score)).map(|(self_score, oppo_score)| {
                let mut test = self.clone();
                let (best_rolls, best_rate) = (0..11u32).map(|rolls| {
                    test.set(rolls, self_score, oppo_score);
                    (rolls, Game::new().win_rate(&mut test, base))
                }).max_by(|(_, rate1), (_, rate2)| rate1.partial_cmp(rate2).unwrap()).unwrap();
                println!("Best rate {} at ({}, {}) by rolling {}", best_rate, self_score, oppo_score, best_rolls);
                (best_rolls, self_score, oppo_score)
            }).collect::<Vec<_>>().drain(..).for_each(|(rolls, self_score, oppo_score)| self.set(rolls, self_score, oppo_score));
            self.export("learn.strat");
        }
        for total in (0..99u32).rev() {
            let mut other = 0;
            while total - other >= 0 {
                let (best_rolls, best_rate) = (0..11u32).into_par_iter().map(|rolls| {
                    let mut test = self.clone();
                    test.set(rolls, total - other, other);
                    (rolls, Game::new().win_rate(&mut test, base))
                }).max_by(|(_, rate1), (_, rate2)| rate1.partial_cmp(rate2).unwrap()).unwrap();
                self.set(best_rolls, total - other, other);
                println!("Best rate {} at ({}, {}) by rolling {}", best_rate, total - other, other, best_rolls);
//                *base = self.clone();
                if total == other { break; } else { other += 1 }
            }
            self.export("learn.strat");
        }
    }

    pub fn get(&self, self_score: u32, oppo_score: u32) -> u32 {
        self.0[(self_score * 100 + oppo_score) as usize]
    }

    pub fn set(&mut self, rolls: u32, self_score: u32, oppo_score: u32) {
        self.0[(self_score * 100 + oppo_score) as usize] = rolls;
    }
}

impl Strategy for PureStrategy {
    fn play(&self, self_score: u32, oppo_score: u32) -> u32 {
        self.get(self_score, oppo_score)
    }
}

pub struct ImpureStrategy(State<u32>);

impl ImpureStrategy {
    pub fn build() -> Self {
        let mut rates = State::new(-1.0);
        let mut moves = State::new(4);
        for i in 0..100 {
            for self_prev in 0..11 {
                for oppo_prev in 0..11 {
                    rates.set(0.0, i, 100, self_prev, oppo_prev, 0);
                    rates.set(1.0, 100, i, self_prev, oppo_prev, 0);
                }
            }
        }
        for total in (99..199u32).rev() {
            let mut score = 99;
            while total - score < 100 {
                for self_prev in 0..11 {
                    for oppo_prev in 0..11 {
                        Self::top_rate(&mut rates, &mut moves, score, total - score, self_prev, oppo_prev);
                    }
                }
                if score == 0 { break; } else { score -= 1 }
            }
        }
        for total in (0..99u32).rev() {
            let mut other = 0;
            while total - other >= 0 {
                for self_prev in 0..11 {
                    for oppo_prev in 0..11 {
                        Self::top_rate(&mut rates, &mut moves, total - other, other, self_prev, oppo_prev);
                    }
                }
                if total == other { break; } else { other += 1 }
            }
        }
        ImpureStrategy(moves)
    }

    fn top_rate(rates: &mut State<f64>, moves: &mut State<u32>, self_score: u32, oppo_score: u32, self_prev: u32, oppo_prev: u32) {
        let mut max_rate = 0.0;
        let mut best_rolls = 4;
        for rolls in 0..11 {
            let mut point = 1;
            let mut win_rate = 0.0;
            while point <= rolls * 6 || rolls == 0 {
                if rolls == 0 {
                    point = Game::free_bacon(oppo_score)
                }
                let mut new_self_score = self_score + point;
                let mut new_oppo_score = oppo_score;
                if (rolls as i32 - self_prev as i32).abs() == 2{
                    new_self_score += 3;
                }
                if Game::is_swap(new_self_score, new_oppo_score) {
                    std::mem::swap(&mut new_self_score, &mut new_oppo_score);
                }

                let mut gain = if new_self_score >= 100 {
                    1.0
                } else if new_oppo_score >= 100 {
                    0.0
                } else {
                    1.0 - rates.get(new_oppo_score, new_self_score, oppo_prev, rolls, 0)
                };

                if rolls == 0 {
                    win_rate = gain;
                    if win_rate > max_rate {
                        max_rate = win_rate;
                        best_rolls = rolls;
                    }
                    break;
                } else {
                    win_rate += gain * Game::probability(rolls, point);
                }
                if win_rate > max_rate {
                    max_rate = win_rate;
                    best_rolls = rolls;
                }
                if point == 1 { point = 2 * rolls - 1; }
                point += 1
            }
        }
        rates.set(max_rate, self_score, oppo_score, self_prev, oppo_prev, 0);
        moves.set(best_rolls, self_score, oppo_score, self_prev, oppo_prev, 0);
    }

    pub fn get(&self, self_score: u32, oppo_score: u32, self_prev: u32, oppo_prev: u32) -> u32 {
        self.0.get(self_score, oppo_score, self_prev, oppo_prev, 0)
    }
}

impl Strategy for ImpureStrategy {
    fn play(&self, self_score: u32, oppo_score: u32) -> u32 {
        self.get(self_score, oppo_score, 0, 0)
    }

    fn full_play(&self, self_score: u32, oppo_score: u32, self_prev: u32, oppo_prev: u32) -> u32 {
        self.get(self_score, oppo_score, self_prev, oppo_prev)
    }
}

pub struct State<T: Clone>(Vec<T>);

impl<T: Clone> State<T> {
    pub fn new(val: T) -> Self {
        State(vec![val; 101 * 101 * 11 * 11 * 2])
    }

    fn get(&self, self_score: u32, oppo_score: u32, self_prev: u32, oppo_prev: u32, who: u32) -> T {
        self.0[Self::index(self_score, oppo_score, self_prev, oppo_prev, who)].clone()
    }

    fn set(&mut self, rate: T, self_score: u32, oppo_score: u32, self_prev: u32, oppo_prev: u32, who: u32) {
        self.0[Self::index(self_score, oppo_score, self_prev, oppo_prev, who)] = rate;
    }

    fn index(self_score: u32, oppo_score: u32, self_prev: u32, oppo_prev: u32, who: u32) -> usize {
        ((((self_score * 101 + oppo_score) * 11 + self_prev) * 11 + oppo_prev) * 2 + who) as usize
    }
}

pub struct Game {
    rates: State<f64>
}

impl Game {
    pub fn new() -> Self {
        Game { rates: State::new(-1.0) }
    }

    pub fn win_rate<S1: Strategy, S2: Strategy>(&mut self, self_strat: &S1, oppo_strat: &S2) -> f64 {
        let first_win_rate = self.compute_win_rate(self_strat, oppo_strat, 0, 0, 0, 0, 0);
        self.rates = State::new(-1.0);
        let second_win_rate = 1.0 - self.compute_win_rate(oppo_strat, self_strat, 0, 0, 0, 0, 0);
        (first_win_rate + second_win_rate) / 2.0
    }

    fn compute_win_rate<S1: Strategy, S2: Strategy>(&mut self, self_strat: &S1, oppo_strat: &S2, self_score: u32, oppo_score: u32, self_prev: u32, oppo_prev: u32, who: u32) -> f64 {
        if self.rates.get(self_score, oppo_score, self_prev, oppo_prev, who) == -1.0 {
            let rolls = self_strat.full_play(self_score, oppo_score, self_prev, oppo_prev);
            let mut win_rate = 0.0;
            let mut point = 1;
            while point <= rolls * 6 || rolls == 0 {
                if rolls == 0 {
                    point = Self::free_bacon(oppo_score);
                }
                let mut new_self_score = self_score + point;
                let mut new_oppo_score = oppo_score;
                if (rolls as i32 - self_prev as i32).abs() == 2 {
                    new_self_score += 3;
                }
                if Self::is_swap(new_self_score, new_oppo_score) {
                    std::mem::swap(&mut new_self_score, &mut new_oppo_score);
                }

                let mut gain = if new_self_score >= 100 {
                    1.0
                } else if new_oppo_score >= 100 {
                    0.0
                } else {
                    1.0 - self.compute_win_rate(oppo_strat, self_strat, new_oppo_score, new_self_score, oppo_prev, rolls, 1 - who)
                };

                if rolls == 0 {
                    win_rate = gain;
                    break;
                } else {
                    win_rate += gain * Self::probability(rolls, point)
                }
                if point == 1 { point = 2 * rolls - 1; }
                point += 1
            }
            self.rates.set(win_rate, self_score, oppo_score, self_prev, oppo_prev, who)
        }
        self.rates.get(self_score, oppo_score, self_prev, oppo_prev, who)
    }

    fn free_bacon(score: u32) -> u32 {
        assert!(score < 100);
        10 - min(score / 10, score % 10)
    }

    fn is_swap(self_score: u32, opponent_score: u32) -> bool {
        let left_digit = |mut n: u32| { while n >= 10 {n /= 10} n };
        let right_digit = |n: u32| n % 10;
        left_digit(self_score) * right_digit(self_score) == left_digit(opponent_score) * right_digit(opponent_score)
    }

    const fn probability(rolls: u32, point: u32) -> f64 {
        const PROB: [[f64; 61]; 11] = [
            [0.0; 61],
            [0.0, 0.166666666666666666666666666667, 0.166666666666666666666666666667, 0.166666666666666666666666666667, 0.166666666666666666666666666667, 0.166666666666666666666666666667, 0.166666666666666666666666666667, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            [0.0, 0.305555555555555555555555555556, 0.0, 0.0, 0.0277777777777777777777777777778, 0.0555555555555555555555555555556, 0.0833333333333333333333333333333, 0.111111111111111111111111111111, 0.138888888888888888888888888889, 0.111111111111111111111111111111, 0.0833333333333333333333333333333, 0.0555555555555555555555555555556, 0.0277777777777777777777777777778, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            [0.0, 0.421296296296296296296296296296, 0.0, 0.0, 0.0, 0.0, 0.00462962962962962962962962962963, 0.0138888888888888888888888888889, 0.0277777777777777777777777777778, 0.0462962962962962962962962962963, 0.0694444444444444444444444444444, 0.0833333333333333333333333333333, 0.0879629629629629629629629629630, 0.0833333333333333333333333333333, 0.0694444444444444444444444444444, 0.0462962962962962962962962962963, 0.0277777777777777777777777777778, 0.0138888888888888888888888888889, 0.00462962962962962962962962962963, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            [0.0, 0.517746913580246913580246913580, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.000771604938271604938271604938272, 0.00308641975308641975308641975309, 0.00771604938271604938271604938272, 0.0154320987654320987654320987654, 0.0270061728395061728395061728395, 0.0401234567901234567901234567901, 0.0524691358024691358024691358025, 0.0617283950617283950617283950617, 0.0655864197530864197530864197531, 0.0617283950617283950617283950617, 0.0524691358024691358024691358025, 0.0401234567901234567901234567901, 0.0270061728395061728395061728395, 0.0154320987654320987654320987654, 0.00771604938271604938271604938272, 0.00308641975308641975308641975309, 0.000771604938271604938271604938272, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            [0.0, 0.598122427983539094650205761317, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.000128600823045267489711934156379, 0.000643004115226337448559670781893, 0.00192901234567901234567901234568, 0.00450102880658436213991769547325, 0.00900205761316872427983539094650, 0.0155606995884773662551440329218, 0.0237911522633744855967078189300, 0.0327932098765432098765432098765, 0.0411522633744855967078189300412, 0.0469393004115226337448559670782, 0.0489969135802469135802469135802, 0.0469393004115226337448559670782, 0.0411522633744855967078189300412, 0.0327932098765432098765432098765, 0.0237911522633744855967078189300, 0.0155606995884773662551440329218, 0.00900205761316872427983539094650, 0.00450102880658436213991769547325, 0.00192901234567901234567901234568, 0.000643004115226337448559670781893, 0.000128600823045267489711934156379, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            [0.0, 0.665102023319615912208504801097, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0000214334705075445816186556927298, 0.000128600823045267489711934156379, 0.000450102880658436213991769547325, 0.00120027434842249657064471879287, 0.00270061728395061728395061728395, 0.00527263374485596707818930041152, 0.00913065843621399176954732510288, 0.0142746913580246913580246913580, 0.0203832304526748971193415637860, 0.0267061042524005486968449931413, 0.0322788065843621399176954732510, 0.0361368312757201646090534979424, 0.0375300068587105624142661179698, 0.0361368312757201646090534979424, 0.0322788065843621399176954732510, 0.0267061042524005486968449931413, 0.0203832304526748971193415637860, 0.0142746913580246913580246913580, 0.00913065843621399176954732510288, 0.00527263374485596707818930041152, 0.00270061728395061728395061728395, 0.00120027434842249657064471879287, 0.000450102880658436213991769547325, 0.000128600823045267489711934156379, 0.0000214334705075445816186556927298, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            [0.0, 0.720918352766346593507087334248, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.00000357224508459076360310928212163, 0.0000250057155921353452217649748514, 0.000100022862368541380887059899406, 0.000300068587105624142661179698217, 0.000750171467764060356652949245542, 0.00162537151348879743941472336534, 0.00312571444901691815272062185642, 0.00542981252857796067672610882487, 0.00862697187928669410150891632373, 0.0126278863740283493369913123000, 0.0171289151806127114769090077732, 0.0216299439871970736168267032465, 0.0255058299039780521262002743484, 0.0281314300411522633744855967078, 0.0290602137631458619112940100594, 0.0281314300411522633744855967078, 0.0255058299039780521262002743484, 0.0216299439871970736168267032465, 0.0171289151806127114769090077732, 0.0126278863740283493369913123000, 0.00862697187928669410150891632373, 0.00542981252857796067672610882487, 0.00312571444901691815272062185642, 0.00162537151348879743941472336534, 0.000750171467764060356652949245542, 0.000300068587105624142661179698217, 0.000100022862368541380887059899406, 0.0000250057155921353452217649748514, 0.00000357224508459076360310928212163, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            [0.0, 0.767431960638622161255906111873, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 5.95374180765127267184880353605E-7, 0.00000476299344612101813747904282884, 0.0000214334705075445816186556927298, 0.0000714449016918152720621856424326, 0.000196473479652491998171010516690, 0.000466773357719859777472946197226, 0.000983558146623990245389422344155, 0.00187185642432556012802926383173, 0.00325967363968907178783721993599, 0.00523929279073311995122694711172, 0.00782321673525377229080932784636, 0.0109072549916171315348270080780, 0.0142532578875171467764060356653, 0.0175040009144947416552354823960, 0.0202427221460143270842859320226, 0.0220764746227709190672153635117, 0.0227224556089010821521109586953, 0.0220764746227709190672153635117, 0.0202427221460143270842859320226, 0.0175040009144947416552354823960, 0.0142532578875171467764060356653, 0.0109072549916171315348270080780, 0.00782321673525377229080932784636, 0.00523929279073311995122694711172, 0.00325967363968907178783721993599, 0.00187185642432556012802926383173, 0.000983558146623990245389422344155, 0.000466773357719859777472946197226, 0.000196473479652491998171010516690, 0.0000714449016918152720621856424326, 0.0000214334705075445816186556927298, 0.00000476299344612101813747904282884, 5.95374180765127267184880353605E-7, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            [0.0, 0.806193300532185134379921759894, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 9.92290301275212111974800589341E-8, 8.93061271147690900777320530407E-7, 0.00000446530635573845450388660265203, 0.0000163727899710409998475842097241, 0.0000491183699131229995427526291724, 0.000126814700502972107910379515318, 0.000289947226032616979119036732205, 0.000598351051668952903520804755373, 0.00112972250800182898948331047096, 0.00197019239318193364832596657014, 0.00319626628943758573388203017833, 0.00485021576360310928212162780064, 0.00691378267413504039018442310623, 0.00928783721993598536808413351623, 0.0117884087791495198902606310014, 0.0141639517604023776863283036123, 0.0161331518632830361225422953818, 0.0174370213191586648376771833562, 0.0178934748577452624091855916273, 0.0174370213191586648376771833562, 0.0161331518632830361225422953818, 0.0141639517604023776863283036123, 0.0117884087791495198902606310014, 0.00928783721993598536808413351623, 0.00691378267413504039018442310623, 0.00485021576360310928212162780064, 0.00319626628943758573388203017833, 0.00197019239318193364832596657014, 0.00112972250800182898948331047096, 0.000598351051668952903520804755373, 0.000289947226032616979119036732205, 0.000126814700502972107910379515318, 0.0000491183699131229995427526291724, 0.0000163727899710409998475842097241, 0.00000446530635573845450388660265203, 8.93061271147690900777320530407E-7, 9.92290301275212111974800589341E-8, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            [0.0, 0.838494417110154278649934799912, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.65381716879202018662466764890E-8, 1.65381716879202018662466764890E-7, 9.09599442835611102643567206896E-7, 0.00000363839777134244441057426882758, 0.0000118247927568629443343663736896, 0.0000329440380023370421175633795661, 0.0000811197321292485901539399481786, 0.000180100689681450998323426306965, 0.000365658976019915663262714017172, 0.000685837979898050771393249674000, 0.00119741324472048637572185811783, 0.00195745800098223509288895662924, 0.00301002993805991634066622635438, 0.00436971572338227573709969686193, 0.00600608512104354011075547426713, 0.00783403269953767210282985317279, 0.00971452204948432657623329776965, 0.0114683951569882639841487578113, 0.0129026680966231434909990008298, 0.0138441035199580009822350928890, 0.0141723035371047773882707581839, 0.0138441035199580009822350928890, 0.0129026680966231434909990008298, 0.0114683951569882639841487578113, 0.00971452204948432657623329776965, 0.00783403269953767210282985317279, 0.00600608512104354011075547426713, 0.00436971572338227573709969686193, 0.00301002993805991634066622635438, 0.00195745800098223509288895662924, 0.00119741324472048637572185811783, 0.000685837979898050771393249674000, 0.000365658976019915663262714017172, 0.000180100689681450998323426306965, 0.0000811197321292485901539399481786, 0.0000329440380023370421175633795661, 0.0000118247927568629443343663736896, 0.00000363839777134244441057426882758, 9.09599442835611102643567206896E-7, 1.65381716879202018662466764890E-7, 1.65381716879202018662466764890E-8]
        ];
        return PROB[rolls as usize][point as usize]
    }
}